#Task 1

#A bubble sort can be modified to “bubble” in both directions.
#The first pass moves “up” the list and the second pass moves “down.” 
#This alternating pattern continues until no more passes are necessary.
#Implement this variation and describe under what circumstances it might be appropriate.

def up_down_bubble_sort(arr):
    n = len(arr)
    begin = 0
    end = n - 1
    swapped = True

    while swapped:
        swapped = False

        # наверх списка
        for i in range(begin, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True

        if not swapped:
            break

        swapped = False
        end -= 1

        # прохід вниз списка
        for i in range(end - 1, begin - 1, -1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True

        begin += 1

    return arr

Двонаправлене сортування методом bubble може бути доречним у випадку, коли
сортування списку майже повністю виконано, і цей список, що
ми сортуємо, має невелику кількість невідсортованих елементів.
Двосторонній прохід може покращити ефективність сортування методом bubble, за рахунок 
пришвидшення переміщення елементів на їх позиції. 
Часова складність бінаправленого бульбашкового сортування складає O(n^2),
як і звичайний bubble sort. він не є надто ефективним, 
тому для списків великих розмірів краще використовувати інші алгоритми, наприклад merge (злиття) , quick sort, або вбудований в Python швидкий і надійний алгоритм sorted()

 

#Task 2

#Implement the mergeSort function without using the slice operator.

def mergeSort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2 
    left = [arr[i] for i in range(mid)] #замість slice застосовую list comprehension 
    right = [arr[i] for i in range(mid, len(arr))]

    left = mergeSort(left)
    right = mergeSort(right)

    return merge(left, right)


def merge(left, right):
    merged = []
    left_ind = 0
    right_ind = 0

    while left_ind < len(left) and right_ind < len(right):
        if left[left_ind] < right[right_ind]:
            merged.append(left[left_ind])
            left_ind += 1
        else:
            merged.append(right[right_ind])
            right_ind += 1

    while left_ind < len(left):
        merged.append(left[left_ind])
        left_ind += 1

    while right_ind < len(right):
        merged.append(right[right_ind])
        right_ind += 1

    return merged




#Task 3

#One way to improve the quicksort is to use an insertion sort on lists that are small in length (call it the “partition limit”). 
#Why does this make sense? Re-implement the quicksort and use it to sort a random list of integers.
#Perform analysis using different list sizes for the partition limit.
