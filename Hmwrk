#Task 1

#A bubble sort can be modified to “bubble” in both directions.
#The first pass moves “up” the list and the second pass moves “down.” 
#This alternating pattern continues until no more passes are necessary.
#Implement this variation and describe under what circumstances it might be appropriate.

def up_down_bubble_sort(arr):
    n = len(arr)
    begin = 0
    end = n - 1
    swapped = True

    while swapped:
        swapped = False

        # наверх списка
        for i in range(begin, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True

        if not swapped:
            break

        swapped = False
        end -= 1

        # прохід вниз списка
        for i in range(end - 1, begin - 1, -1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True

        begin += 1

    return arr






 

#Task 2

#Implement the mergeSort function without using the slice operator.

 

#Task 3

#One way to improve the quicksort is to use an insertion sort on lists that are small in length (call it the “partition limit”). 
#Why does this make sense? Re-implement the quicksort and use it to sort a random list of integers.
#Perform analysis using different list sizes for the partition limit.
